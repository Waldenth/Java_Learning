# 多线程

> 多线程即在同一时间，可以做多件事情。
>
> 创建多线程有3种方式，分别是[继承线程类](https://how2j.cn/k/thread/thread-start/353.html#step778),[实现Runnable接口](https://how2j.cn/k/thread/thread-start/353.html#step779),[匿名类](https://how2j.cn/k/thread/thread-start/353.html#step780)

## 启动一个线程

> 首先要理解进程(Processor)和线程(Thread)的区别
> **进程：**启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。
> **线程：**线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如"盖伦” 击杀“提莫”，**同时**“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。

### 创建多线程-继承线程类

使用多线程，就可以做到盖伦在攻击提莫的**同时**，赏金猎人也在攻击盲僧
设计一个类`KillThread `**继承Thread**，**并且重写run方法**
启动线程办法： 实例化一个`KillThread`对象，并且调用其**start**方法
就可以观察到 赏金猎人攻击盲僧的**同时**，盖伦也在攻击提莫

```java
package multiplethread;
 
import charactor.Hero;
 
public class KillThread extends Thread{
    private Hero h1;
    private Hero h2;
 
    public KillThread(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }
    
    public void run(){ //重写run方法
        while(!h2.isDead()){
            h1.attackHero(h2);
        }
    }
}
```

```java
package multiplethread;
 
import charactor.Hero;
 
public class TestThread {
 
    public static void main(String[] args) {
         
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
 
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
         
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
         
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
         
        KillThread killThread1 = new KillThread(gareen,teemo);
        killThread1.start();
        KillThread killThread2 = new KillThread(bh,leesin);
        killThread2.start();
         
    } 
}
```

### 创建多线程-实现Runnable接口

创建类Battle，实现Runnable接口
启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动

 ```java
Battle battle1 = new Battle(gareen,teemo);

new Thread(battle1).start();
 ```

battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。
必须，借助一个线程对象的start()方法，才会启动一个新的线程。
所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。

```java
package multiplethread;
 
import charactor.Hero;
 
public class Battle implements Runnable{
     
    private Hero h1;
    private Hero h2;
 
    public Battle(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }
 
    public void run(){
        while(!h2.isDead()){
            h1.attackHero(h2);
        }
    }
}
```

```java
package multiplethread;
 
import charactor.Hero;
 
public class TestThread {
 
    public static void main(String[] args) {
         
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
 
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
         
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
         
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
        
        //启动的时候，首先创建一个Battle对象，
        //然后再根据该battle对象创建一个线程对象，并启动
        Battle battle1 = new Battle(gareen,teemo);
         
        new Thread(battle1).start();
 
        Battle battle2 = new Battle(bh,leesin);
        new Thread(battle2).start();
 
    }
     
}
```

### 创建多线程-匿名类

使用[匿名类](https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687)，继承Thread,重写run方法，直接在run方法中写业务代码
匿名类的一个好处是可以很方便的访问外部的局部变量。
前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
  
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
          
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
          
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
          
        //匿名类
        Thread t1= new Thread(){
            public void run(){
                //匿名类中用到外部的局部变量teemo，必须把teemo声明为final
                //但是在JDK7以后，就不是必须加final的了
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
         
        t1.start();
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
        t2.start();
         
    } 
}
```

### 三种创建线程的方式

把上述3种方式再整理一下：

1. 继承Thread类
2. 实现Runnable接口
3. 匿名类的方式

注： 启动线程是start()方法，run()并不能启动一个新的线程

## 常见线程方法

| 关键字        | 简介             | 示例代码                                                     |
| :------------ | :--------------- | :----------------------------------------------------------- |
| sleep         | 当前线程暂停     | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step781) |
| join          | 加入到当前线程中 | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step782) |
| `setPriority` | 线程优先级       | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step783) |
| yield         | 临时暂停         | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step784) |
| `setDaemon`   | 守护线程         | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step2403) |

### Sleep

`Thread.sleep(1000)`; 表示当前线程暂停1000毫秒 ，其他线程不受影响
`Thread.sleep(1000)`; 会抛出`InterruptedException `中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出` InterruptedException`

```java
package multiplethread;
 
public class TestThread {
    public static void main(String[] args) {
         
        Thread t1= new Thread(){
            public void run(){
                int seconds =0;
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.printf("已经玩了LOL %d 秒%n", seconds++);
                }              
            }
        };
        t1.start();      
    }
}
```

### 加入到当前线程中

首先解释一下**主线程**的概念
所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个**看不见**的主线程存在。
在42行执行`t.join`，即表明**在主线程中加入该线程**。
主线程会等待该线程结束完毕， 才会往下运行。

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
          
        Thread t1= new Thread(){
            public void run(){
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        t1.start();
 
        //代码执行到这里，一直是main线程在运行
        try {
            //t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走
            t1.join();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
        //会观察到盖伦把提莫杀掉后，才运行t2线程
        t2.start();    
    } 
}
```

### 线程优先级

当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源
为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源
同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示
如图可见，线程1的优先级是`MAX_PRIORITY`，所以它争取到了更多的CPU资源执行代码

```java
package charactor;
  
import java.io.Serializable;
   
public class Hero{
    public String name;
    public float hp;
      
    public int damage;
      
    public void attackHero(Hero h) {
        //把暂停时间去掉，多条线程各自会尽力去占有CPU资源
        //线程的优先级效果才可以看得出来
//        try {
//           
//            Thread.sleep(0);
//        } catch (InterruptedException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
          
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 6160;
        gareen.damage = 1;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 3000;
        teemo.damage = 1;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 5000;
        bh.damage = 1;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 4505;
        leesin.damage = 1;
          
        Thread t1= new Thread(){
            public void run(){
 
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
         
        t1.setPriority(Thread.MAX_PRIORITY); //最高优先级
        t2.setPriority(Thread.MIN_PRIORITY); //最低优先级
        t1.start();
        t2.start();
          
    } 
}
```

### 临时暂停

当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 61600;
        gareen.damage = 1;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 30000;
        teemo.damage = 1;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 50000;
        bh.damage = 1;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 45050;
        leesin.damage = 1;
          
        Thread t1= new Thread(){
            public void run(){
 
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    //临时暂停，使得t1可以占用CPU资源
                    Thread.yield();
                     
                    bh.attackHero(leesin);
                }              
            }
        };
         
        t1.setPriority(5);
        t2.setPriority(5);
        t1.start();
        t2.start();
          
    }
      
}
```

### 守护线程

守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。

就好像一个公司有销售部，生产部这些和业务挂钩的部门。
除此之外，还有后勤，行政等这些支持部门。

如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。

守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。

守护线程通常会被用来做日志，性能统计等工作。

```java
package multiplethread;
  
public class TestThread {
    public static void main(String[] args) {  
        Thread t1= new Thread(){
            public void run(){
                int seconds =0;
                 
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.printf("已经玩了LOL %d 秒%n", seconds++);
                     
                }              
            }
        };
        t1.setDaemon(true); //设置为守护线程
        t1.start();     
    }  
}
```

无运行结果，直接停止

## 同步

> 多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题
>
> 多线程的问题，又叫**Concurrency** 问题

### 同步问题

假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击
就是**有多个线程在减少盖伦的hp**
同时又有**多个线程在恢复盖伦的hp**
假设线程的数量是一样的，并且每次改变的值都是1，那么所有线程结束后，盖伦应该还是10000滴血。
但是。。。

![](https://stepimagewm.how2j.cn/786.png)

**注意**： 不是每一次运行都会看到错误的数据产生，多运行几次，或者增加运行的次数

#### 原因

\1. 假设**增加线程**先进入，得到的hp是10000
\2. 进行增加运算
\3. 正在做增加运算的时候，**还没有来得及修改hp的值**，**减少线程**来了
\4. 减少线程得到的hp的值也是10000
\5. 减少线程进行减少运算
\6. 增加线程运算结束，得到值10001，并把这个值赋予hp
\7. 减少线程也运算结束，得到值9999，并把这个值赋予hp
hp，最后的值就是9999
虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999
这个时候的值9999是一个错误的值，在业务上又叫做**脏数据**

![](https://gitee.com/waldenth/blogimage/raw/master/img/787.png)

#### 解决

总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp
\1. 增加线程获取到hp的值，并进行运算
\2. 在运算期间，减少线程试图来获取hp的值，但是**不被允许**
\3. 增加线程运算结束，并成功修改hp的值为10001
\4. 减少线程，在增加线程做完后，才能访问hp的值，即10001
\5. 减少线程运算，并得到新的值10000

![](https://gitee.com/waldenth/blogimage/raw/master/img/788.png)

#### synchronized 同步对象概念

解决上述问题之前，先理解
**synchronized**关键字的意义
如下代码：

```java
Object someObject =new Object();
synchronized (someObject){
  //此处的代码只有占有了someObject后才可以执行
}
```

**synchronized表示当前线程，独占 对象 someObject**
当前线程**独占** 了对象someObject，如果有**其他线程** **试图占有对象**someObject，**就会等待**，直到当前线程释放对someObject的占用。
someObject 又叫同步对象，所有的对象，都可以作为同步对象
为了达到同步的效果，必须使用同一个同步对象

**释放同步对象**的方式： synchronized 块自然结束，或者有异常抛出

![](https://gitee.com/waldenth/blogimage/raw/master/img/789.png)

```java
package multiplethread;
  
import java.text.SimpleDateFormat;
import java.util.Date;
   
public class TestThread {
     
    public static String now(){
        return new SimpleDateFormat("HH:mm:ss").format(new Date());
    }
     
    public static void main(String[] args) {
        final Object someObject = new Object();
          
        Thread t1 = new Thread(){
            public void run(){
                try {
                    System.out.println( now()+" t1 线程已经运行");
                    System.out.println( now()+this.getName()+ " 试图占有对象：someObject");
                    synchronized (someObject) {
                          
                        System.out.println( now()+this.getName()+ " 占有对象：someObject");
                        Thread.sleep(5000);
                        System.out.println( now()+this.getName()+ " 释放对象：someObject");
                    }
                    System.out.println(now()+" t1 线程结束");
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        };
        t1.setName(" t1");
        t1.start();
        Thread t2 = new Thread(){
  
            public void run(){
                try {
                    System.out.println( now()+" t2 线程已经运行");
                    System.out.println( now()+this.getName()+ " 试图占有对象：someObject");
                    synchronized (someObject) {
                        System.out.println( now()+this.getName()+ " 占有对象：someObject");
                        Thread.sleep(5000);
                        System.out.println( now()+this.getName()+ " 释放对象：someObject");
                    }
                    System.out.println(now()+" t2 线程结束");
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        };
        t2.setName(" t2");
        t2.start();
    }    
}
```

#### 使用synchronized 解决同步问题

所有需要修改hp的地方，有要**建立在占有someObject的基础上**。
而对象 someObject在同一时间，只能被一个线程占有。 间接地，**导致同一时间，hp只能被一个线程修改。**

```java
package multiplethread;
   
import java.awt.GradientPaint;
import charactor.Hero;
   
public class TestThread {
   
    public static void main(String[] args) {
 
        final Object someObject = new Object();
         
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 10000;
          
        int n = 10000;
  
        Thread[] addThreads = new Thread[n];
        Thread[] reduceThreads = new Thread[n];
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                     
                    //任何线程要修改hp的值，必须先占用someObject
                    synchronized (someObject) {
                        gareen.recover();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            addThreads[i] = t;
              
        }
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                    //任何线程要修改hp的值，必须先占用someObject
                    synchronized (someObject) {
                        gareen.hurt();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            reduceThreads[i] = t;
        }
          
        for (Thread t : addThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (Thread t : reduceThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
          
        System.out.printf("%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n", n,n,gareen.hp);
          
    }
}
```

#### 使用hero对象作为同步对象

既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，**索性就使用gareen来作为同步对象**
进一步的，对于Hero的hurt方法，加上：

```java
synchronized (this) {
}
```

表示当前对象为同步对象，即也是`gareen`为同步对象

可以在Hero的方法中使用this做同步对象，线程直接调用这种方法

也可以线程中使用操作的对象作为同步对象，获取后调用对象方法

```java
package charactor;
  
public class Hero{
    public String name;
    public float hp;
     
    public int damage;
     
    //回血
    public void recover(){
        hp=hp+1;
    }
     
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;   
        }
    }
     
    public void attackHero(Hero h) {
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

```java
package multiplethread;
import java.awt.GradientPaint; 
import charactor.Hero;
   
public class TestThread {
   
    public static void main(String[] args) {
 
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 10000;
          
        int n = 10000;
  
        Thread[] addThreads = new Thread[n];
        Thread[] reduceThreads = new Thread[n];
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                     
                    //使用gareen作为synchronized
                    synchronized (gareen) {
                        gareen.recover();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            addThreads[i] = t;
              
        }
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                    //使用gareen作为synchronized
                    //在方法hurt中有synchronized(this)
                    gareen.hurt();
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            reduceThreads[i] = t;
        }
          
        for (Thread t : addThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (Thread t : reduceThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
          
        System.out.printf("%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n", n,n,gareen.hp);
          
    }     
}
```

#### 在方法前，加上修饰符synchronized

在recover前，直接加上`synchronized` ，其所对应的同步对象，就是this
和hurt方法达到的效果是一样
外部线程访问`gareen`的方法，就不需要额外使用`synchronized` 了

```java
package charactor;
  
public class Hero{
    public String name;
    public float hp;
     
    public int damage;
     
    //回血
    //直接在方法前加上修饰符synchronized
    //其所对应的同步对象，就是this
    //和hurt方法达到的效果一样
    public synchronized void recover(){
        hp=hp+1;
    }
     
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;   
        }
    }
     
    public void attackHero(Hero h) {
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

#### 线程安全类

如果一个类，其**方法都是有synchronized修饰的**，那么该类就叫做**线程安全的类**

同一时间，只有一个线程能够进入 **这种类的一个实例** 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)

比如StringBuffer和StringBuilder的区别
StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类
而StringBuilder就不是线程安全的类

面试试题：https://how2j.cn/k/thread/thread-thread-safe/703.html

## 死锁 Deadlock

当业务比较复杂，多线程应用里有可能会发生**死锁**

### 死锁产生

1. 线程1 首先占有对象1，接着试图占有对象2
2. 线程2 首先占有对象2，接着试图占有对象1
3. 线程1 等待线程2释放对象2
4. 与此同时，线程2等待线程1释放对象1

```java
package multiplethread;

import charactor.Hero;

public class TestThreadDeadClock {
    public static void main(String[] args) {
        final Hero ahri = new Hero();
        ahri.name = "九尾妖狐";
        final Hero annie = new Hero();
        annie.name = "安妮";
         
        Thread t1 = new Thread(){
            public void run(){
                //占有九尾妖狐
                synchronized (ahri) {
                    System.out.println("t1 已占有九尾妖狐");
                    try {
                        //停顿1000毫秒，另一个线程有足够的时间占有安妮
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                     
                    System.out.println("t1 试图占有安妮");
                    System.out.println("t1 等待中 。。。。");
                    synchronized (annie) {
                        System.out.println("do something");
                    }
                }  
                 
            }
        };
        t1.start();
        Thread t2 = new Thread(){
            public void run(){
                //占有安妮
                synchronized (annie) {
                    System.out.println("t2 已占有安妮");
                    try {
                         
                        //停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println("t2 试图占有九尾妖狐");
                    System.out.println("t2 等待中 。。。。");
                    synchronized (ahri) {
                        System.out.println("do something");
                    }
                }  
                 
            }
        };
        t2.start();
   } 
}
```

## 交互

> 线程之间有**交互通知**的需求，考虑如下情况：
> 有两个线程，处理同一个英雄。
> 一个加血，一个减血。
>
> 减血的线程，发现血量=1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血

### 不好的解决方式

故意设计减血线程频率更高，盖伦的血量迟早会到达1
减血线程中**使用while循环判断是否是1**，如果是1就不停的循环,直到加血线程回复了血量
**这是不好的解决方式，因为会大量占用CPU,拖慢性能**

```java
Thread t1 = new Thread(){
            public void run(){
                while(true){
                     
                    //因为减血更快，所以盖伦的血量迟早会到达1
                    //使用while循环判断是否是1，如果是1就不停的循环
                    //直到加血线程回复了血量
                    while(gareen.hp==1){
                        continue;
                    }
                     
                    gareen.hurt();
                    System.out.printf("t1 为%s 减血1点,减少血后，%s的血量是%.0f%n",gareen.name,gareen.name,gareen.hp);
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
 
            }
        };
```

### 使用wait和notify进行线程交互

在Hero类中：hurt()减血方法：当hp=1的时候，执行this.wait().
this.wait()**表示 让占有this的线程等待，并临时释放占有**
进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 **这样加血线程，就有机会进入recover()加血方法了**。


recover() 加血方法：增加了血量，执行`this.notify();`
`this.notify() `表示通知那些**等待在this的线程**，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦`recover()`结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。

![](https://gitee.com/waldenth/blogimage/raw/master/img/796.png)

### 关于wait notify notifyAll

这里需要强调的是，`wait`方法和`notify`方法，并**不是Thread线程上的方法**，它们是`Object`上的方法。

因为所有的`Object`都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。

`wait()`的意思是： 让占用了这个同步对象的**线程**，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在`synchronized`块里，否则就会出错。

`notify() `的意思是，通知**一个**等待在这个同步对象上的线程，**你**可以苏醒过来了，有机会重新占用当前对象了。

`notifyAll()` 的意思是，通知**所有的**等待在这个同步对象上的线程，**你们**可以苏醒过来了，有机会重新占用当前对象了

## 线程池

> 每一个线程的启动和结束都是比较消耗时间和占用资源的。
>
> 如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。
>
> 为了解决这个问题，引入线程池这种设计思想。
>
> 线程池的模式很像[生产者消费者模式](https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591)，消费的对象是一个一个的能够运行的**任务**

### 线程池设计思路

线程池的思路和[生产者消费者模型](https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591)是很接近的。

1. 准备一个任务容器
2. 一次性启动10个 消费者线程
3. 刚开始任务容器是空的，所以线程都**wait**在上面。
4. 直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被
5. 这个消费者线程取出“任务”，并且**执行这个任务**，执行完毕后，继续等待下一次任务的到来。
6. 如果短时间内，有较多的任务加入，那么就会有多个线程被**唤醒**，去执行这些任务。

在整个过程中，都不需要创建新的线程，而是**循环使用这些已经存在的线程**

![](https://gitee.com/waldenth/blogimage/raw/master/img/2600.png)

### 自定义线程池

这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理

缓慢的给这个线程池添加任务，会看到有多条线程来执行这些任务。
线程7执行完毕任务后，**又回到池子里**，下一次任务来的时候，线程7又来执行新的任务。

```java
package multiplethread;
  
import java.util.LinkedList;
  
public class ThreadPool {
  
    // 线程池大小
    int threadPoolSize;
  
    // 任务容器
    LinkedList<Runnable> tasks = new LinkedList<Runnable>();
  
    // 试图消费任务的线程
  
    public ThreadPool() {
        threadPoolSize = 10;
  
        // 启动10个任务消费者线程
        synchronized (tasks) {
            for (int i = 0; i < threadPoolSize; i++) {
                new TaskConsumeThread("任务消费者线程 " + i).start();
            }
        }
    }
  
    public void add(Runnable r) {
        synchronized (tasks) {
            tasks.add(r);
            // 唤醒等待的任务消费者线程
            tasks.notifyAll();
        }
    }
  
    class TaskConsumeThread extends Thread {
        public TaskConsumeThread(String name) {
            super(name);
        }
  
        Runnable task;
  
        public void run() {
            System.out.println("启动： " + this.getName());
            while (true) {
                synchronized (tasks) {
                    while (tasks.isEmpty()) {
                        try {
                            tasks.wait();
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                    task = tasks.removeLast();
                    // 允许添加任务的线程可以继续添加任务
                    tasks.notifyAll();
  
                }
                System.out.println(this.getName() + " 获取到任务，并执行");
                task.run();
            }
        }
    }
}
```

```java
package multiplethread;

public class TestThreadPool {
    public static void main(String[] args) {
        ThreadPool pool = new ThreadPool();
  
        for (int i = 0; i < 20; i++) {
            Runnable task = new Runnable() {
                public void run() {
                    //System.out.println("执行任务");
                    //任务可能是打印一句话
                    //可能是访问文件
                    //可能是做排序
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
             
            pool.add(task);
             
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
  
    }
}

```

```bash
启动： 任务消费者线程 3
启动： 任务消费者线程 2
启动： 任务消费者线程 4
启动： 任务消费者线程 6
启动： 任务消费者线程 1
启动： 任务消费者线程 5
启动： 任务消费者线程 0
任务消费者线程 3 获取到任务，并执行
启动： 任务消费者线程 7
启动： 任务消费者线程 8
启动： 任务消费者线程 9
任务消费者线程 4 获取到任务，并执行
任务消费者线程 9 获取到任务，并执行
任务消费者线程 4 获取到任务，并执行
任务消费者线程 9 获取到任务，并执行
任务消费者线程 3 获取到任务，并执行
任务消费者线程 4 获取到任务，并执行
任务消费者线程 9 获取到任务，并执行
任务消费者线程 3 获取到任务，并执行
任务消费者线程 9 获取到任务，并执行
任务消费者线程 8 获取到任务，并执行

```

### Java自带的线程池

java提供自带的线程池，而不需要自己去开发一个自定义线程池了。

线程池类**ThreadPoolExecutor**在包**java.util.concurrent**下

```java
ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
```

**第一个**参数10 表示这个线程池**初始化了10个**线程在里面工作
**第二个**参数15 表示如果10个线程不够用了，就会自动增加到**最多15个线程**
**第三个**参数60 结合第四个参数`TimeUnit.SECONDS`，表示经过**60秒**，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个
**第四个**参数`TimeUnit.SECONDS `如上
**第五个**参数 `new LinkedBlockingQueue() `用来放任务的集合

**execute**方法用于添加新的任务

```java
package multiplethread;
   
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
   
public class TestThread {
    public static void main(String[] args) throws InterruptedException {
           
        ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
           
        threadPool.execute(new Runnable(){
   
            @Override
            public void run() {
                // TODO Auto-generated method stub
                System.out.println("任务1");
            }
               
        });
   
    }
}
```

## Lock对象

> 与synchronized类似的，lock也能够达到同步的效果

Lock是一个接口，为了使用一个Lock对象，需要用到

 ```java
Lock lock = new ReentrantLock();
 ```

与 **synchronized (someObject)** 类似的，**lock()**方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。
与 **synchronized** 不同的是，一旦synchronized 块结束，就会自动释放对**someObject**的占用。 lock却必须调用**unlock**方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。

```java
package multiplethread;
 
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
public class TestThread {
 
    public static String now() {
        return new SimpleDateFormat("HH:mm:ss").format(new Date());
    }
 
    public static void log(String msg) {
        System.out.printf("%s %s %s %n", now() , Thread.currentThread().getName() , msg);
    }
 
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
 
        Thread t1 = new Thread() {
            public void run() {
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
 
                    lock.lock();
 
                    log("占有对象：lock");
                    log("进行5秒的业务操作");
                    Thread.sleep(5000);
 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    log("释放对象：lock");
                    lock.unlock();
                }
                log("线程结束");
            }
        };
        t1.setName("t1");
        t1.start();
        try {
            //先让t1飞2秒
            Thread.sleep(2000);
        } catch (InterruptedException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        Thread t2 = new Thread() {
 
            public void run() {
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
 
                    lock.lock();
 
                    log("占有对象：lock");
                    log("进行5秒的业务操作");
                    Thread.sleep(5000);
 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    log("释放对象：lock");
                    lock.unlock();
                }
                log("线程结束");
            }
        };
        t2.setName("t2");
        t2.start();
    }
}
```

```bash
17:32:45 t1 线程启动
17:32:45 t1 试图占有对象：lock
17:32:45 t1 占有对象：lock
17:32:45 t1 进行5秒的业务操作
17:32:47 t2 线程启动
17:32:47 t2 试图占有对象：lock
17:32:50 t1 释放对象：lock
17:32:50 t1 线程结束
17:32:50 t2 占有对象：lock
17:32:50 t2 进行5秒的业务操作
17:32:55 t2 释放对象：lock
17:32:55 t2 线程结束
```

### try Lock

synchronized 是**不占用到手不罢休**的，会一直试图占用下去。
与 synchronized 的**钻牛角尖**不一样，Lock接口还提供了一个`trylock`方法。
`trylock`会在指定时间范围内**试图占用**，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~

注意： 因为使用`trylock`有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常

```java
public class TestThread {
 
    public static String now() {
        return new SimpleDateFormat("HH:mm:ss").format(new Date());
    }
 
    public static void log(String msg) {
        System.out.printf("%s %s %s %n", now() , Thread.currentThread().getName() , msg);
    }
 
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
 
        Thread t1 = new Thread() {
            public void run() {
                boolean locked = false;
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
 
                    locked = lock.tryLock(1,TimeUnit.SECONDS);
                    if(locked){
                        log("占有对象：lock");
                        log("进行5秒的业务操作");
                        Thread.sleep(5000);
                    }
                    else{
                        log("经过1秒钟的努力，还没有占有对象，放弃占有");
                    }
 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                     
                    if(locked){
                        log("释放对象：lock");
                        lock.unlock();
                    }
                }
                log("线程结束");
            }
        };
        t1.setName("t1");
        t1.start();
        try {
            //先让t1飞2秒
            Thread.sleep(2000);
        } catch (InterruptedException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        Thread t2 = new Thread() {
 
            public void run() {
                boolean locked = false;
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
 
                    locked = lock.tryLock(1,TimeUnit.SECONDS);
                    if(locked){
                        log("占有对象：lock");
                        log("进行5秒的业务操作");
                        Thread.sleep(5000);
                    }
                    else{
                        log("经过1秒钟的努力，还没有占有对象，放弃占有");
                    }
 
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                     
                    if(locked){
                        log("释放对象：lock");
                        lock.unlock();
                    }
                }
                log("线程结束");
            }
        };
        t2.setName("t2");
        t2.start();
    }
}
```

```
17:36:27 t1 线程启动
17:36:27 t1 试图占有对象：lock
17:36:27 t1 占有对象：lock
17:36:27 t1 进行5秒的业务操作
17:36:29 t2 线程启动
17:36:29 t2 试图占有对象：lock
17:36:30 t2 经过1秒钟的努力，还没有占有对象，放弃占有
17:36:30 t2 线程结束
17:36:32 t1 释放对象：lock
17:36:32 t1 线程结束
```

### Lock 线程交互

使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法

Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：**await**, **signal**,**signalAll** 方法

**注意**： 不是Condition对象的wait,nofity,notifyAll方法,**而是await,signal,signalAll**

```java
package multiplethread;
  
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
  
public class TestThread {
  
    public static String now() {
        return new SimpleDateFormat("HH:mm:ss").format(new Date());
    }
  
    public static void log(String msg) {
        System.out.printf("%s %s %s %n", now() , Thread.currentThread().getName() , msg);
    }
  
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
         
        Thread t1 = new Thread() {
            public void run() {
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
  
                    lock.lock();
  
                    log("占有对象：lock");
                    log("进行5秒的业务操作");
                    Thread.sleep(5000);
                    log("临时释放对象 lock， 并等待");
                    condition.await();
                    log("重新占有对象 lock，并进行5秒的业务操作");
                    Thread.sleep(5000);
  
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    log("释放对象：lock");
                    lock.unlock();
                }
                log("线程结束");
            }
        };
        t1.setName("t1");
        t1.start();
        try {
            //先让t1飞2秒
            Thread.sleep(2000);
        } catch (InterruptedException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        Thread t2 = new Thread() {
  
            public void run() {
                try {
                    log("线程启动");
                    log("试图占有对象：lock");
  
                    lock.lock();
  
                    log("占有对象：lock");
                    log("进行5秒的业务操作");
                    Thread.sleep(5000);
                    log("唤醒等待中的线程");
                    condition.signal();
  
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    log("释放对象：lock");
                    lock.unlock();
                }
                log("线程结束");
            }
        };
        t2.setName("t2");
        t2.start();
    }
}
```

### 总结Lock和synchronized的区别

1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。

2. Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。

3. synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。