# 多线程

> 多线程即在同一时间，可以做多件事情。
>
> 创建多线程有3种方式，分别是[继承线程类](https://how2j.cn/k/thread/thread-start/353.html#step778),[实现Runnable接口](https://how2j.cn/k/thread/thread-start/353.html#step779),[匿名类](https://how2j.cn/k/thread/thread-start/353.html#step780)

## 启动一个线程

> 首先要理解进程(Processor)和线程(Thread)的区别
> **进程：**启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。
> **线程：**线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如"盖伦” 击杀“提莫”，**同时**“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。

### 创建多线程-继承线程类

使用多线程，就可以做到盖伦在攻击提莫的**同时**，赏金猎人也在攻击盲僧
设计一个类`KillThread `**继承Thread**，**并且重写run方法**
启动线程办法： 实例化一个`KillThread`对象，并且调用其**start**方法
就可以观察到 赏金猎人攻击盲僧的**同时**，盖伦也在攻击提莫

```java
package multiplethread;
 
import charactor.Hero;
 
public class KillThread extends Thread{
    private Hero h1;
    private Hero h2;
 
    public KillThread(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }
    
    public void run(){ //重写run方法
        while(!h2.isDead()){
            h1.attackHero(h2);
        }
    }
}
```

```java
package multiplethread;
 
import charactor.Hero;
 
public class TestThread {
 
    public static void main(String[] args) {
         
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
 
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
         
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
         
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
         
        KillThread killThread1 = new KillThread(gareen,teemo);
        killThread1.start();
        KillThread killThread2 = new KillThread(bh,leesin);
        killThread2.start();
         
    } 
}
```

### 创建多线程-实现Runnable接口

创建类Battle，实现Runnable接口
启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动

 ```java
Battle battle1 = new Battle(gareen,teemo);

new Thread(battle1).start();
 ```

battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。
必须，借助一个线程对象的start()方法，才会启动一个新的线程。
所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。

```java
package multiplethread;
 
import charactor.Hero;
 
public class Battle implements Runnable{
     
    private Hero h1;
    private Hero h2;
 
    public Battle(Hero h1, Hero h2){
        this.h1 = h1;
        this.h2 = h2;
    }
 
    public void run(){
        while(!h2.isDead()){
            h1.attackHero(h2);
        }
    }
}
```

```java
package multiplethread;
 
import charactor.Hero;
 
public class TestThread {
 
    public static void main(String[] args) {
         
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
 
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
         
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
         
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
        
        //启动的时候，首先创建一个Battle对象，
        //然后再根据该battle对象创建一个线程对象，并启动
        Battle battle1 = new Battle(gareen,teemo);
         
        new Thread(battle1).start();
 
        Battle battle2 = new Battle(bh,leesin);
        new Thread(battle2).start();
 
    }
     
}
```

### 创建多线程-匿名类

使用[匿名类](https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687)，继承Thread,重写run方法，直接在run方法中写业务代码
匿名类的一个好处是可以很方便的访问外部的局部变量。
前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
  
        Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
          
        Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
          
        Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
          
        //匿名类
        Thread t1= new Thread(){
            public void run(){
                //匿名类中用到外部的局部变量teemo，必须把teemo声明为final
                //但是在JDK7以后，就不是必须加final的了
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
         
        t1.start();
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
        t2.start();
         
    } 
}
```

### 三种创建线程的方式

把上述3种方式再整理一下：

1. 继承Thread类
2. 实现Runnable接口
3. 匿名类的方式

注： 启动线程是start()方法，run()并不能启动一个新的线程

## 常见线程方法

| 关键字        | 简介             | 示例代码                                                     |
| :------------ | :--------------- | :----------------------------------------------------------- |
| sleep         | 当前线程暂停     | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step781) |
| join          | 加入到当前线程中 | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step782) |
| `setPriority` | 线程优先级       | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step783) |
| yield         | 临时暂停         | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step784) |
| `setDaemon`   | 守护线程         | [示例代码](https://how2j.cn/k/thread/thread-methods/354.html#step2403) |

### Sleep

`Thread.sleep(1000)`; 表示当前线程暂停1000毫秒 ，其他线程不受影响
`Thread.sleep(1000)`; 会抛出`InterruptedException `中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出` InterruptedException`

```java
package multiplethread;
 
public class TestThread {
    public static void main(String[] args) {
         
        Thread t1= new Thread(){
            public void run(){
                int seconds =0;
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.printf("已经玩了LOL %d 秒%n", seconds++);
                }              
            }
        };
        t1.start();      
    }
}
```

### 加入到当前线程中

首先解释一下**主线程**的概念
所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个**看不见**的主线程存在。
在42行执行`t.join`，即表明**在主线程中加入该线程**。
主线程会等待该线程结束完毕， 才会往下运行。

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 616;
        gareen.damage = 50;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 300;
        teemo.damage = 30;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 500;
        bh.damage = 65;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 455;
        leesin.damage = 80;
          
        Thread t1= new Thread(){
            public void run(){
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        t1.start();
 
        //代码执行到这里，一直是main线程在运行
        try {
            //t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走
            t1.join();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
        //会观察到盖伦把提莫杀掉后，才运行t2线程
        t2.start();    
    } 
}
```

### 线程优先级

当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源
为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源
同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示
如图可见，线程1的优先级是`MAX_PRIORITY`，所以它争取到了更多的CPU资源执行代码

```java
package charactor;
  
import java.io.Serializable;
   
public class Hero{
    public String name;
    public float hp;
      
    public int damage;
      
    public void attackHero(Hero h) {
        //把暂停时间去掉，多条线程各自会尽力去占有CPU资源
        //线程的优先级效果才可以看得出来
//        try {
//           
//            Thread.sleep(0);
//        } catch (InterruptedException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
          
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 6160;
        gareen.damage = 1;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 3000;
        teemo.damage = 1;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 5000;
        bh.damage = 1;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 4505;
        leesin.damage = 1;
          
        Thread t1= new Thread(){
            public void run(){
 
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    bh.attackHero(leesin);
                }              
            }
        };
         
        t1.setPriority(Thread.MAX_PRIORITY); //最高优先级
        t2.setPriority(Thread.MIN_PRIORITY); //最低优先级
        t1.start();
        t2.start();
          
    } 
}
```

### 临时暂停

当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源

```java
package multiplethread;
  
import charactor.Hero;
  
public class TestThread {
  
    public static void main(String[] args) {
          
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 61600;
        gareen.damage = 1;
  
        final Hero teemo = new Hero();
        teemo.name = "提莫";
        teemo.hp = 30000;
        teemo.damage = 1;
          
        final Hero bh = new Hero();
        bh.name = "赏金猎人";
        bh.hp = 50000;
        bh.damage = 1;
          
        final Hero leesin = new Hero();
        leesin.name = "盲僧";
        leesin.hp = 45050;
        leesin.damage = 1;
          
        Thread t1= new Thread(){
            public void run(){
 
                while(!teemo.isDead()){
                    gareen.attackHero(teemo);
                }              
            }
        };
          
        Thread t2= new Thread(){
            public void run(){
                while(!leesin.isDead()){
                    //临时暂停，使得t1可以占用CPU资源
                    Thread.yield();
                     
                    bh.attackHero(leesin);
                }              
            }
        };
         
        t1.setPriority(5);
        t2.setPriority(5);
        t1.start();
        t2.start();
          
    }
      
}
```

### 守护线程

守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。

就好像一个公司有销售部，生产部这些和业务挂钩的部门。
除此之外，还有后勤，行政等这些支持部门。

如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。

守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。

守护线程通常会被用来做日志，性能统计等工作。

```java
package multiplethread;
  
public class TestThread {
    public static void main(String[] args) {  
        Thread t1= new Thread(){
            public void run(){
                int seconds =0;
                 
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.printf("已经玩了LOL %d 秒%n", seconds++);
                     
                }              
            }
        };
        t1.setDaemon(true); //设置为守护线程
        t1.start();     
    }  
}
```

无运行结果，直接停止

## 同步

> 多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题
>
> 多线程的问题，又叫**Concurrency** 问题

### 同步问题

假设盖伦有10000滴血，并且在基地里，同时又被对方多个英雄攻击
就是**有多个线程在减少盖伦的hp**
同时又有**多个线程在恢复盖伦的hp**
假设线程的数量是一样的，并且每次改变的值都是1，那么所有线程结束后，盖伦应该还是10000滴血。
但是。。。

![](https://stepimagewm.how2j.cn/786.png)

**注意**： 不是每一次运行都会看到错误的数据产生，多运行几次，或者增加运行的次数

#### 原因

\1. 假设**增加线程**先进入，得到的hp是10000
\2. 进行增加运算
\3. 正在做增加运算的时候，**还没有来得及修改hp的值**，**减少线程**来了
\4. 减少线程得到的hp的值也是10000
\5. 减少线程进行减少运算
\6. 增加线程运算结束，得到值10001，并把这个值赋予hp
\7. 减少线程也运算结束，得到值9999，并把这个值赋予hp
hp，最后的值就是9999
虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999
这个时候的值9999是一个错误的值，在业务上又叫做**脏数据**

![](https://gitee.com/waldenth/blogimage/raw/master/img/787.png)

#### 解决

总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp
\1. 增加线程获取到hp的值，并进行运算
\2. 在运算期间，减少线程试图来获取hp的值，但是**不被允许**
\3. 增加线程运算结束，并成功修改hp的值为10001
\4. 减少线程，在增加线程做完后，才能访问hp的值，即10001
\5. 减少线程运算，并得到新的值10000

![](https://gitee.com/waldenth/blogimage/raw/master/img/788.png)

#### synchronized 同步对象概念

解决上述问题之前，先理解
**synchronized**关键字的意义
如下代码：

```java
Object someObject =new Object();
synchronized (someObject){
  //此处的代码只有占有了someObject后才可以执行
}
```

**synchronized表示当前线程，独占 对象 someObject**
当前线程**独占** 了对象someObject，如果有**其他线程** **试图占有对象**someObject，**就会等待**，直到当前线程释放对someObject的占用。
someObject 又叫同步对象，所有的对象，都可以作为同步对象
为了达到同步的效果，必须使用同一个同步对象

**释放同步对象**的方式： synchronized 块自然结束，或者有异常抛出

![](https://gitee.com/waldenth/blogimage/raw/master/img/789.png)

```java
package multiplethread;
  
import java.text.SimpleDateFormat;
import java.util.Date;
   
public class TestThread {
     
    public static String now(){
        return new SimpleDateFormat("HH:mm:ss").format(new Date());
    }
     
    public static void main(String[] args) {
        final Object someObject = new Object();
          
        Thread t1 = new Thread(){
            public void run(){
                try {
                    System.out.println( now()+" t1 线程已经运行");
                    System.out.println( now()+this.getName()+ " 试图占有对象：someObject");
                    synchronized (someObject) {
                          
                        System.out.println( now()+this.getName()+ " 占有对象：someObject");
                        Thread.sleep(5000);
                        System.out.println( now()+this.getName()+ " 释放对象：someObject");
                    }
                    System.out.println(now()+" t1 线程结束");
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        };
        t1.setName(" t1");
        t1.start();
        Thread t2 = new Thread(){
  
            public void run(){
                try {
                    System.out.println( now()+" t2 线程已经运行");
                    System.out.println( now()+this.getName()+ " 试图占有对象：someObject");
                    synchronized (someObject) {
                        System.out.println( now()+this.getName()+ " 占有对象：someObject");
                        Thread.sleep(5000);
                        System.out.println( now()+this.getName()+ " 释放对象：someObject");
                    }
                    System.out.println(now()+" t2 线程结束");
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        };
        t2.setName(" t2");
        t2.start();
    }    
}
```

#### 使用synchronized 解决同步问题

所有需要修改hp的地方，有要**建立在占有someObject的基础上**。
而对象 someObject在同一时间，只能被一个线程占有。 间接地，**导致同一时间，hp只能被一个线程修改。**

```java
package multiplethread;
   
import java.awt.GradientPaint;
import charactor.Hero;
   
public class TestThread {
   
    public static void main(String[] args) {
 
        final Object someObject = new Object();
         
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 10000;
          
        int n = 10000;
  
        Thread[] addThreads = new Thread[n];
        Thread[] reduceThreads = new Thread[n];
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                     
                    //任何线程要修改hp的值，必须先占用someObject
                    synchronized (someObject) {
                        gareen.recover();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            addThreads[i] = t;
              
        }
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                    //任何线程要修改hp的值，必须先占用someObject
                    synchronized (someObject) {
                        gareen.hurt();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            reduceThreads[i] = t;
        }
          
        for (Thread t : addThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (Thread t : reduceThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
          
        System.out.printf("%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n", n,n,gareen.hp);
          
    }
}
```

#### 使用hero对象作为同步对象

既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，**索性就使用gareen来作为同步对象**
进一步的，对于Hero的hurt方法，加上：

```java
synchronized (this) {
}
```

表示当前对象为同步对象，即也是`gareen`为同步对象

可以在Hero的方法中使用this做同步对象，线程直接调用这种方法

也可以线程中使用操作的对象作为同步对象，获取后调用对象方法

```java
package charactor;
  
public class Hero{
    public String name;
    public float hp;
     
    public int damage;
     
    //回血
    public void recover(){
        hp=hp+1;
    }
     
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;   
        }
    }
     
    public void attackHero(Hero h) {
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

```java
package multiplethread;
import java.awt.GradientPaint; 
import charactor.Hero;
   
public class TestThread {
   
    public static void main(String[] args) {
 
        final Hero gareen = new Hero();
        gareen.name = "盖伦";
        gareen.hp = 10000;
          
        int n = 10000;
  
        Thread[] addThreads = new Thread[n];
        Thread[] reduceThreads = new Thread[n];
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                     
                    //使用gareen作为synchronized
                    synchronized (gareen) {
                        gareen.recover();
                    }
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            addThreads[i] = t;
              
        }
          
        for (int i = 0; i < n; i++) {
            Thread t = new Thread(){
                public void run(){
                    //使用gareen作为synchronized
                    //在方法hurt中有synchronized(this)
                    gareen.hurt();
                     
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            };
            t.start();
            reduceThreads[i] = t;
        }
          
        for (Thread t : addThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (Thread t : reduceThreads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
          
        System.out.printf("%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n", n,n,gareen.hp);
          
    }     
}
```

#### 在方法前，加上修饰符synchronized

在recover前，直接加上`synchronized` ，其所对应的同步对象，就是this
和hurt方法达到的效果是一样
外部线程访问`gareen`的方法，就不需要额外使用`synchronized` 了

```java
package charactor;
  
public class Hero{
    public String name;
    public float hp;
     
    public int damage;
     
    //回血
    //直接在方法前加上修饰符synchronized
    //其所对应的同步对象，就是this
    //和hurt方法达到的效果一样
    public synchronized void recover(){
        hp=hp+1;
    }
     
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;   
        }
    }
     
    public void attackHero(Hero h) {
        h.hp-=damage;
        System.out.format("%s 正在攻击 %s, %s的血变成了 %.0f%n",name,h.name,h.name,h.hp);
        if(h.isDead())
            System.out.println(h.name +"死了！");
    }
  
    public boolean isDead() {
        return 0>=hp?true:false;
    }
}
```

#### 线程安全类

如果一个类，其**方法都是有synchronized修饰的**，那么该类就叫做**线程安全的类**

同一时间，只有一个线程能够进入 **这种类的一个实例** 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)

比如StringBuffer和StringBuilder的区别
StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类
而StringBuilder就不是线程安全的类

面试试题：https://how2j.cn/k/thread/thread-thread-safe/703.html